#pragma once
#include <string>
#include <vector>
#include "misc.h"
#include "rendering.h"

struct Ray {

};

struct RaycastResult {
    // todo

    RaycastResult pick_closest(RaycastResult other);
};


struct Object {
    enum class ObjectType {
        Normal,
        Edited, // is currently being edited
        LuaGenerated, // generated by a lua script, geometry shouldn't be changed
    } type = ObjectType::Normal;

    std::string name{"New object"};

    ray::Vector3 position{}, scale{1,1,1};
    ray::Quaternion rotation = ray::QuaternionIdentity();

    std::vector<ray::Vector3> vertices{};
    std::vector<int> triangle_indexes{}; // CCW winding order
    std::vector<ray::Color> triangle_colors{};

    std::vector<Object> children{};

    std::string lua_path{}; // only used if type is LuaGenerated

    ray::Matrix get_model_matrix();
    void add_to_render(Renderer &renderer, ray::Matrix &parent_transform);
    RaycastResult& raycast(Ray r);

    static Object new_triangle();
    static Object new_cube();
    static Object new_iso_sphere();
    static Object new_cylinder();
    static Object new_torus();
    static Object new_cone();
    static Object new_lua(std::string path);
};

struct World {
    struct CameraSettings {
        ray::Vector3 position{1.5, 2, 2.5}, target{0,0,0}, up{0, 1, 0};
        bool is_perspective = true;
        float fov = PI/2.; // ignored if is_perspective = false

        ray::Matrix get_view_projection_matrix();
    } camera{};
    std::vector<Object> objects{};

    void render(bool debug_render = false);
    RaycastResult& raycast(Ray r);
};
